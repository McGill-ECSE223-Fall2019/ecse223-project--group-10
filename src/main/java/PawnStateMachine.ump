namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;

class PawnBehavior {
	depend java.util.HashMap;
    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;

    pawnSM {
    	Playing{
    		NorthSouth{
    			Setup{
    				startGame -> AtNorthEdge
    			}
    			AtNorthEdge{
    				moveUp -> /{illegalMove();} AtNorthEdge;
    				moveDown [isLegalStep(MoveDirection.South) && !isLegalJump(MoveDirection.South)] -> AtNorthBorder;
    				moveDown [isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South)] -> MiddleNS;
    			}
    			AtNorthBorder{
    				moveUp [isLegalStep(MoveDirection.North)]  -> AtNorthEdge;
    				moveDown [isLegalStep(MoveDirection.South)] -> MiddleNS;
    			}
    			AtSouthEdge{
    				moveUp [isLegalStep(MoveDirection.North) && !isLegalJump(MoveDirection.North)]  -> AtNorthBorder;
    				moveUp [isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North)]  -> MiddleNS;
    				moveDown -> AtSouthEdge;
    			} 
    			AtSouthBorder{
    				moveUp [isLegalStep(MoveDirection.North)] -> MiddleNS;
    				moveDown [isLegalStep(MoveDirection.South)] -> AtSouthEdge;
    			}
    			MiddleNS{
    				moveUp [isLegalStep(MoveDirection.North) && !isLegalJump(MoveDirection.North) && getCurrentPawnRow()==3] -> AtNorthBorder;
    				moveUp [isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North) && getCurrentPawnRow()==3] -> AtNorthEdge;
    				moveUp [isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North) && getCurrentPawnRow()==4] -> AtNorthBorder;
    				moveUp -> MiddleNS;
    				
    				moveDown [isLegalStep(MoveDirection.South) && !isLegalJump(MoveDirection.South) && getCurrentPawnRow()==7] -> AtSouthBorder;
    				moveDown [isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South) && getCurrentPawnRow()==7] -> AtSouthEdge;
    				moveDown [isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South) && getCurrentPawnRow()==6] -> AtNorthBorder;
    				moveDown -> MiddleNS;
    			}
    		} 
    		||
    		
    		EastWest{
    			Setup{
    				startGame -> MiddleEW
    			}
    			AtEastEdge{
    				moveRight -> AtEastEdge;
    				moveLeft [isLegalStep(MoveDirection.West) && !isLegalJump(MoveDirection.West)] -> AtWestBorder;
    				moveLeft [isLegalStep(MoveDirection.West) && isLegalJump(MoveDirection.West)] -> MiddleEW;
    			}
    			AtEastBorder{
    				moveRight [isLegalStep(MoveDirection.East)]  -> AtEastEdge;
    				moveLeft [isLegalStep(MoveDirection.West)] -> MiddleEW;
    			}
    			AtWestEdge{
    				moveRight [isLegalStep(MoveDirection.East) && !isLegalJump(MoveDirection.East)]  -> AtWestBorder;
    				moveRight [isLegalStep(MoveDirection.East) && isLegalJump(MoveDirection.East)]  -> MiddleEW;
    				moveLeft -> AtWestEdge;
    			} 
    			AtWestBorder{
    				moveRight [isLegalStep(MoveDirection.North)] -> MiddleEW;
    				moveLeft [isLegalStep(MoveDirection.South)] -> AtWestEdge;
    			}
    			MiddleEW{
    				moveRight [isLegalStep(MoveDirection.East) && !isLegalJump(MoveDirection.East) && getCurrentPawnColumn()==7] -> AtEastBorder;
    				moveRight [isLegalStep(MoveDirection.East) && isLegalJump(MoveDirection.East) && getCurrentPawnColumn()==7] -> AtEastEdge;
    				moveRight [isLegalStep(MoveDirection.East) && isLegalJump(MoveDirection.East) && getCurrentPawnColumn()==6] -> AtEastBorder;
    				moveRight -> MiddleEW;
    				
    				moveLeft [isLegalStep(MoveDirection.West) && !isLegalJump(MoveDirection.West) && getCurrentPawnColumn()==3] -> AtWestBorder;
    				moveLeft [isLegalStep(MoveDirection.West) && isLegalJump(MoveDirection.West) && getCurrentPawnColumn()==3] -> AtWestEdge;
    				moveLeft [isLegalStep(MoveDirection.West) && isLegalJump(MoveDirection.West) && getCurrentPawnColumn()==4] -> AtWestBorder;
    				moveLeft -> MiddleEW;
    			}
    		}
    	}
    	
    	Finished{
  
    	}
    }
    
    // Returns the current row number of the pawn
    int getCurrentPawnRow() { 
		if(player==currentGame.getWhitePlayer()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getRow();
		}
		return currentGame.getCurrentPosition().getBlackPosition().getTile().getRow();
	}
    
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() { 
		if(player==currentGame.getWhitePlayer()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getColumn();
		}
		return currentGame.getCurrentPosition().getBlackPosition().getTile().getColumn();
	}
    
    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) { 
    	HashMap<Integer, Boolean> wallMap = getWallMap();
	int row = getCurrentPawnRow();
	int col = getCurrentPawnColumn();
	PlayerPosition otherPlayerPosition = player.equals(currentGame.getWhitePlayer())?currentGame.getCurrentPosition().getBlackPosition():currentGame.getCurrentPosition().getWhitePosition();
	int otherRow = otherPlayerPosition.getTile().getRow();
	int otherCol = otherPlayerPosition.getTile().getColumn();
    switch(dir) {
    		case North:
    			row--;
    			if(pawnSMPlayingNorthSouth==PawnSMPlayingNorthSouth.Null || pawnSMPlayingNorthSouthNorthSouth==PawnSMPlayingNorthSouthNorthSouth.AtNorthEdge)return false;
    			if(pawnSMPlayingEastWestEastWest!=PawnSMPlayingEastWestEastWest.AtWestEdge&&wallMap.containsKey((row)*9+col-1)&&wallMap.get((row)*9+col-1))return false;
    			if(pawnSMPlayingEastWestEastWest!=PawnSMPlayingEastWestEastWest.AtEastEdge&&wallMap.containsKey((row)*9+col)&&wallMap.get((row)*9+col))return false;
    			if(col==otherCol&&row==otherRow)return false;
    			break;
    		case South:
    			row++;
    			if(pawnSMPlayingNorthSouth==PawnSMPlayingNorthSouth.Null || pawnSMPlayingNorthSouthNorthSouth==PawnSMPlayingNorthSouthNorthSouth.AtSouthEdge)return false;
    			if(pawnSMPlayingEastWestEastWest!=PawnSMPlayingEastWestEastWest.AtWestEdge&&wallMap.containsKey((row)*9+col-1)&&wallMap.get((row)*9+col-1))return false;
    			if(pawnSMPlayingEastWestEastWest!=PawnSMPlayingEastWestEastWest.AtEastEdge&&wallMap.containsKey((row)*9+col)&&wallMap.get((row)*9+col))return false;
    			if(col==otherCol&&row==otherRow)return false;
    			break;
    		case West:
    			col--;
    			if(pawnSMPlayingEastWest==PawnSMPlayingEastWest.Null||pawnSMPlayingEastWestEastWest==PawnSMPlayingEastWestEastWest.AtWestBorder)return false;
    			if(pawnSMPlayingNorthSouthNorthSouth!=PawnSMPlayingNorthSouthNorthSouth.AtSouthEdge&&wallMap.containsKey((row)*9+col)&&!wallMap.get((row)*9+col))return false;
    			if(pawnSMPlayingNorthSouthNorthSouth!=PawnSMPlayingNorthSouthNorthSouth.AtNorthEdge&&wallMap.containsKey((row-1)*9+col)&&!wallMap.get((row-1)*9+col))return false;
    			if(col==otherCol&&row==otherRow)return false;
    			break;
    		case East:
    			col++;
    			if(pawnSMPlayingEastWest==PawnSMPlayingEastWest.Null||pawnSMPlayingEastWestEastWest==PawnSMPlayingEastWestEastWest.AtWestBorder)return false;
    			if(pawnSMPlayingNorthSouthNorthSouth!=PawnSMPlayingNorthSouthNorthSouth.AtSouthEdge&&wallMap.containsKey((row)*9+col)&&!wallMap.get((row)*9+col))return false;
    			if(pawnSMPlayingNorthSouthNorthSouth!=PawnSMPlayingNorthSouthNorthSouth.AtNorthEdge&&wallMap.containsKey((row-1)*9+col)&&!wallMap.get((row-1)*9+col))return false;
    			if(col==otherCol&&row==otherRow)return false;
    			break;
    	}
    return true;
    }
    
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) {
    	switch(dir) {
    		case North:
    			break;
    		case South:
    			break;
    		case West:
    			break;
    		case East:
    			break;
    	}
    return true;
    }
	HashMap<Integer,Boolean> getWallMap(){
	  HashMap<Integer, Boolean> wallPositions = new HashMap<Integer, Boolean>();		
		//TODO: switch to player list (more convenient if 2+)
		for (Wall wall : currentGame.getCurrentPosition().getBlackWallsOnBoard()) {
			if(wall.equals(currentGame.getWallMoveCandidate().getWallPlaced()))continue;
			WallMove wall_move = wall.getMove();
			int row = wall_move.getTargetTile().getRow();
			int col = wall_move.getTargetTile().getColumn();
			boolean dir_attr = false;
			if (wall_move.getWallDirection().equals(Direction.Horizontal))
				dir_attr = true;
			wallPositions.put(row * 9 + col, dir_attr);
		}
		for (Wall wall : currentGame.getCurrentPosition().getWhiteWallsOnBoard()) {
			if(wall.equals(currentGame.getWallMoveCandidate().getWallPlaced()))continue;
			WallMove wall_move = wall.getMove();
			int row = wall_move.getTargetTile().getRow();
			int col = wall_move.getTargetTile().getColumn();
			boolean dir_attr = false;
			if (wall_move.getWallDirection().equals(Direction.Horizontal))
				dir_attr = true;
			wallPositions.put(row * 9 + col, dir_attr);
		}
		return wallPositions;
  }
    // Action to be called when an illegal move is attempted
    void illegalMove() { }
    
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North ;}
}
